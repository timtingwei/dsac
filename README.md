动手实现一下《数据结构》严蔚敏

其他参考: 《大话数据结构》

## ch1 绪论

## ch2 线性表 

### 2.3 线性表链式实现

#### 2.3.1 线性链表

##### 单链表
> * 1, 线性表的单链表存储结构
> * 2, 单链表插入
> * 3, 单链表删除
> * 4, 头插法, 建立带头结点的单链线性表  (类似于插队, 参考《大话数据结构》)
> * 5, 尾插法 (正常的排队逻辑, 参考《大话数据结构》)
> * 6, 归并两个有序链表

##### 静态链表
> * 1, 线性静态链表存储结构
> * 2, 将space分量初始化成备用链表
> * 3, 手动实现malloc()分配空间
> * 4, 获取静态链表的长度
> * 5, 静态链表插入
> * 6, 静态链表删除
> * 7, 手动实现Free() 回收空间

> * 8, 静态链表中查找
> * 9, 静态链表整表添加
> * 10, 静态链表整体删除
> * 11, 归并两个有序静态链表(仍旧有问题, 需要参考数据结构p33)

#### 2.3.2 循环链表

特点:从表中最后一个结点的指针域指向头结点, 整个链表形成一个环
与线性链表的差别: 仅在于算法中的循环条件不是p或p->next是否为空，而是他们是否等于头指针.

```cpp
// 将两个循环链表合并成一个表, (参考大话数据结构)
p = rearA->next;   // 保存a表的头结点
rearA->next = rearB->next->next;       // 将本指向B表的第一个结点, 赋值给rearA->next
q = rearB->next;   // 保存b表的头结点
rearB->next = p;   // a表的头结点赋值给rearB->next
free(q);           // 释放q, b表原来的头结点被释放
```

#### 2.3.3 双向链表


单链表缺点: NextElem的执行时间为O(1), 而PriorElem的执行时间为O(n).
双向链表(double linked list)是在单链表的每个结点中, 再设置一个指向其前驱结点的指针

后继的前驱, 前驱的后继, 都是它自己
```cpp
d->next->prior = d->prior->next =  d;
```

插入:
1, s在p之后
```cpp
s->prior = p;        s->next = p->next;
p->next->prior = s;  p->next = s;
```

2, s在p之前
```cpp
s->prior = p->prior; s->next = p;
p->prior = s;        s->prior->next = s;
```

删除p
```cpp
p->prior->next = p->next;
p->next->prior = p->prior;
free(p);
```

实现:

> * 1, 双向链表存储结构
> * 2, 初始化成空的双向循环链表
> * 3, 返回双向循环链表的长度（bug, 解决）
> * 4, 双向循环链表的查找(bug, 凭空多处一位, 已经解决)
> * 5, 双向循环链表的插入
> * 6, 双向循环链表的删除



### 2.4 一元多项式的表示以及相加
暂时跳过, 学习栈和队列

### 总结一下:
线性表分为顺序存储和链式储存;
链式储存分为: 单链表, 静态链表, 循环链表, 双向链表


## 3. 栈和队列

### 3.1 栈(stack)

限定在表尾进行插入或者删除操作的线性表。
表尾称为 **栈顶** (top),  表头称为 **栈底** (top), 不含元素的空表称为空栈。
满足 **后进先出** (Last in First Out = LIFO)原则。
联想: 铁路调度站台, 土坑

> * 1, 栈的插入(push)
> * 2, 栈的删除(pop)
> * 3, 取栈顶元素(top)
> * 4, 栈的初始化(init)
> * 5, 判空(empty)

### 3.2 栈的应用举例

1, 数制转换, conversion(求余结果入栈, 先进后出原则, 先被计算的在最后被打印输出)
2, 括号匹配的检验, brackets_mactch(用栈表示期待的迫切程度,)
3, 行编辑程序, LineEdit(栈作为输入缓冲区)

```cpp
// 行编辑程序的记录
// debug1: 在外循环进入前, 先getchar一个字符, 如果ch==EOF,
// 对于外层循环结束, 在内存循环结束后, 同样getchar()一次;
// debug2: 在声明一个stack后InitStack(), 如果只是清空stack缓存, ClearStack();
// debug3: 如果这个栈的函数结束后不再有作用, DestroyStack()
// ClearStack() 和 DestroyStack(), 定义和声明在Stack头文件中
// improve: 三个并列的if, 改写成switch
```

4, 迷宫求解(没做)
5, 表达式求值(没做)
四则运算表达式求值(《大话数据结构》没做)

### 3.3 栈的递归实现(没实现)

有的数据结构, 如二叉树, 广义表, 结构本身就有递归特性, 他们的操作可以递归描述;
有的一类问题, 问题本身没有递归描述, 但用递归求解比迭代求解更简单, 八皇后, Hanoi塔问题


### 3.4 队列

队列(queue)是一种先进先出(first in first out, FIFO)的线性表

只允许在队尾(rear)插入元素, 在队头(front)删除元素

应用: 操作系统中的作业排队

与栈的区别: 操作类似, 但队列的删除操作在队头(front)进行

双端队列: 限定插入和删除操作在表的两端进行的线性表;
输出受限(一端可插可删, 另一端只插), 输入受限（一端可插可删, 另一端只可删)
一个端点插入的元素, 只能从该端点删的双端队列, 变成了两个栈底相邻的栈.

### 3.4.2 链队列

需要头尾两个指针才能唯一确定;
空的链队列的判定条件: 头指针和尾指针指向头结点;

```cpp
// LinkQueue.c
// - - - - - 单链队列-----队列的链式存储结构 - - - - -
typedef struct QNode {
  QElemType       data;
  struct QNode   * next;
} QNode, * QueuePtr;

typedef struct {
  QueuePtr front;    // 队头指针
  QueuePtr rear;     // 队尾指针
}LinkQueue;
```

> * 1, 存储结构
> * 2, 构造空链队列
> * 3, 销毁队列
> * 4, 队列Q的队尾插入元素e(ps:插入新元素需要分配空间)
> * 5, 队列Q的队首删除元素e(考虑队列空的情况 和 删除最后一个结点的情况)

删除操作, 一般情况只要改变front中的指针, 但当队列中最后一个元素被删除后， 队列rear指针丢失, 需要对队尾指针重新赋值(与front相同, 指向头结点);
