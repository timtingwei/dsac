/* Copyright [2019] <mituh> */
/* Floyd.c */
/* 有权图的多源最短路径 */

/* 稀疏图, N次调用Dijskra算法 O(|V|^3 + |E|*|V|);
   稠密图, Floyd算法 O(|V|^3) */

/* G初始化成G[i][j] = E<i, j>, 对角元为0 */

void Floyd() {
  for (i = 0; i < N; i++) {
    for (j = 0; j < N; j++) {
      D[i][j] = G[i][j];
      path[i][j] = -1;
    }
  }

  for (k = 0; k < N; k++) {
    for (i = 0; i < N; i++) {
      for (j = 0; j < N; j++) {
        if (D[i][k] + D[k][j] < D[i][j]) {
          D[i][j] = D[i][k] + D[k][j];
          path[i][j] = k;
        }
      }
    }
  }
}

/*
Floyd算法与负值圈:
如果图中有负值圈，Floyd算法还能用吗？如何知道图中是否存在负值圈？
需要进行简单变换就可以使用Floyd算法
可以将负值视为某种不可无限重复的路径
1）检是否有负值圈（检查权重是否有负值，并找出最小负值）
2）如果有负值圈，对所有非对角元的权重增加最小负值+1（例如最小负值为-10，则所有非对角元的权+11），最小负值变为1.
3）使用Floyd算法
4）最短路径及长度：直接输出矩阵中保存的最短路径，并记录该最短路径经过的边个数n，长度等于矩阵中保存的长度减去最短路径经过的边的个数倍的最小负值+1
*/
